=== Constraints

For the last two iterations of the day, ask people to switch pairs before the last iteration, but let them keep their changes and continue working from that point.
http://legacycoderetreat.typepad.com/blog/2011/11/how-i-run-legacy-code-retreat.html

=== Characterization test

- setting up a safety net
- only focus on inputs and outputs
- do not make changes to the production code

==== Hand written System Tests

==== Golden Master Tests

=== Want more?
Refactoring golf code bases
https://github.com/daviddenton/refactoring-golf
https://github.com/snahider/Refactoring-Golf
https://github.com/emilybache/GildedRose-Refactoring-Kata

[%notitle]
=== The Great Goat
image::https://upload.wikimedia.org/wikipedia/commons/b/b2/Hausziege_04.jpg[canvas,size=contain]


=== Definitions
Legacy Code:: https://en.wikipedia.org/wiki/Legacy_code

Characterization tests:: https://en.wikipedia.org/wiki/Characterization_test n computer programming, a characterization test is a means to describe (characterize) the actual behavior of an existing piece of software, and therefore protect existing behavior of legacy code against unintended changes via automated testing.
This term was coined by Michael Feathers.

=== Legacy Code
[quote, Michael Feathers, 'Working Effectively with Legacy Code']
____
To me, legacy code is simply code without tests.
____

Surviving Legacy Code with Golden Master and Sampling
[quote, J. B. Rainsberger, 'http://blog.thecodewhisperer.com/permalink/surviving-legacy-code-with-golden-master-and-sampling']
____
Legacy code is valuable code that we feel afraid to change.
____


=== What is important when working with legacy code
1. Every change needs a Why and a stopping point
1. Focus on on thing at the time
1. Reading Code
   1. Active code reading (rename )
1. Executing Code
1. Get test coverage
1. Refactoring
   1. Mikado method https://mikadomethod.wordpress.com/
1. Take small steps
1. Run your tests
1. Commit often
1. Make sure that your test are failing in the way you expect them to
1. Use automated refactorings where possible
   1. Know their limitations/quirks/bugs
1. Get your dependencies under control
   1. Dependency inversion
   1. Dependency injection
   1. Extract and override
   1. Power Mocking tools

Structure changes vs. Functional changes

=== What makes legacy code hard to test
static dependencies are the problem, meaning we can not exchange them in our tests


Road to happiness:  adding black box system tests to create a safety net -> characterization tests -> component tests -> unit tests
